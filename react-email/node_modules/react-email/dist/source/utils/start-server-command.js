"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.buildProdServer = exports.startProdServer = exports.startDevServer = void 0;
const shelljs_1 = __importDefault(require("shelljs"));
let processesToKill = [];
function execAsync(command) {
    const process = shelljs_1.default.exec(command, { async: true });
    processesToKill.push(process);
    process.on('close', () => {
        processesToKill = processesToKill.filter((p) => p !== process);
    });
}
const startDevServer = (packageManager, port) => {
    execAsync(`${packageManager} run dev -- -p ${port}`);
};
exports.startDevServer = startDevServer;
const startProdServer = (packageManager, port) => {
    execAsync(`${packageManager} run start -- -p ${port}`);
};
exports.startProdServer = startProdServer;
const buildProdServer = (packageManager) => {
    execAsync(`${packageManager} run build`);
    // if build fails for whatever reason, make sure the shell actually exits
    process.on('close', (code) => {
        shelljs_1.default.exit(code ?? undefined);
    });
};
exports.buildProdServer = buildProdServer;
// based on https://stackoverflow.com/a/14032965
function exitHandler() {
    if (processesToKill.length > 0) {
        console.log('shutting down %d subprocesses', processesToKill.length);
    }
    processesToKill.forEach((p) => {
        if (p.connected) {
            p.kill();
        }
    });
}
// do something when app is closing
process.on('exit', exitHandler);
// catches ctrl+c event
process.on('SIGINT', exitHandler);
//  catches "kill pid" (for example: nodemon restart)
process.on('SIGUSR1', exitHandler);
process.on('SIGUSR2', exitHandler);
// catches uncaught exceptions
process.on('uncaughtException', exitHandler);
